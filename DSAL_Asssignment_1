#include<iostream>
#include<bits/stdc++.h>

using namespace std;

class Node{
	class Node* left;
	class Node* right;
public:
	int data;
	Node(){
		data=0;
		left =NULL;
		right = NULL;
	}
	Node(int d){
		data = d;
		left =NULL;
		right = NULL;
	}
	friend class Tree;
};
class Stack
{
    public:
    int tp;
    Node *data[30];
    Stack()
    {
        tp = -1;
    }
    void push(Node *);
    Node *pop();
    int empty();
    int full();
    Node* top();
};
Node* Stack:: top(){
	return data[this->tp];
}
int Stack::empty()
{
    if(tp == -1)
    {
        return 1;
    }
    return 0;
}
int Stack::full()
{
    if(tp == 29)
    {
        return 1;
    }
    return 0;
}
void Stack::push(Node *p)
{
    if(!full())
    {
        tp++;
        data[tp] = p;
    }
    else
    {
        cout<<"\nStack is full\n";
    }
}
Node *Stack::pop()
{
    Node *x;
    if(!empty())
    {
        x = data[tp];
        tp--;
        return x;
    }
    else
    {
        cout<<"\nStack is empty\n";
        return NULL;
    }
}


class Tree{

	Node* root;
public:
	Node* getroot(){
		return root;
	}
	Tree(){
		root = NULL;

	}

	void cre(){
		root = create();
	}
	Node* create();
	void Preorder(Node* root);
	void Postorder(Node* root);
	void Inorder(Node* root);
	void Preorder_nr(Node* root);
	void Postorder_nr(Node* root);
	void Inorder_nr(Node* root);
	Node* search(Node* root,int data);
	void search_s();
	void Insert_pos(Node* root);
	Node* Mirror_bt(Node* root,Node* mirror_node);
	int height(Node* root);
	void Mirror(Tree t);
	Tree operator =(Tree t);
	Node* operator = (Node* s);
	int internal(Node* node);
	int  leaf(Node* node);
};
Node* Tree:: create(){
	Node* new_node = new Node();
	cout<<"Enter a data you want to insert"<<endl;
	int d;
	cin >> d;
	new_node->data =d;
	char ans;
	cout<<"Does node "<<d<<" have left child(y/n"<<endl;
	cin >> ans;
	if(ans =='y'){
		new_node->left = create();
	}else{
		new_node->left = NULL;
	}
	cout<<"Does node "<<d<<" have right child (y/n)"<<endl;
	cin >> ans;
	if(ans=='y'){
		new_node->right= create();

	}else{
		new_node->right = NULL;
	}
	return new_node;
}
void Tree:: Preorder(Node* root){
	if(root==NULL){
		cout<<"It is an empty tree"<<endl;
	}
	cout<<root->data<<" ";
	if(root->left!=NULL){
		Preorder(root->left);
	}
	if(root->right!=NULL){
		Preorder(root->right);
	}

}
void Tree:: Postorder(Node* root){
	if(root==NULL){
		cout<<"It is an empty tree"<<endl;
	}
	if(root->left!=NULL){
		Postorder(root->left);
	}
	if(root->right!=NULL){
		Postorder(root->right);
	}
	cout<<root->data<<" ";

}
void Tree:: Inorder(Node* root){

	if(root==NULL){
			cout<<"It is an empty tree"<<endl;
		}
	if(root->left!=NULL){
		Inorder(root->left);
	}
	cout<<root->data<<" ";
	if(root->right!=NULL){
		Inorder(root->right);
	}

}
void Tree:: Preorder_nr(Node* root){
	Stack st;
		st.push(root);
		while(!st.empty() ){
			Node* temp=st.top();
			st.pop();
			cout<<temp->data<<" ";
			if(temp->right!=NULL){
				st.push(temp->right);
			}
			if(temp->left!=NULL){
				st.push(temp->left);
			}

		}
}
void Tree:: Postorder_nr(Node* root){
	Node* curr=root;
	Stack  st;
	while(true){
		if(curr!=NULL){
			st.push(curr);
			curr = curr->left;
		}else{
			if(st.empty()){
				break;
			}
			curr=st.top()->right;
			if(curr==NULL){
				Node* last = NULL;
				while(!st.empty() && st.top()->right==last){
					last = st.top();
					st.pop();
					cout<<last->data<<" ";
				}
			}
		}
	}
}
void Tree:: Inorder_nr(Node* root){
	Stack st;
	Node* temp= root;
	while(!st.empty() || temp!=NULL){
		if(temp!=NULL){
			st.push(temp);
			temp=temp->left;
		}else{
			temp = st.top();
			st.pop();
			cout<<temp->data<<" ";
			temp = temp->right;
		}
	}
}
Node* Tree:: search(Node* root,int d){
	Stack  st;
		st.push(root);
		while(!st.empty() ){
			Node* temp=st.top();
			st.pop();
			if(temp->data==d){
				return temp;
			}
			if(temp->right!=NULL){
				st.push(temp->right);
			}
			if(temp->left!=NULL){
				st.push(temp->left);
			}

		}
		return NULL;
}
void Tree:: search_s(){
	int s;
	cout<<"Enter a key you want to search "<<endl;
	cin >> s;
	Node* temp = search(this->root,s);
	if(temp!=NULL){
		cout<<"We have found it...! "<<endl;
	}else{
		cout<<"Data no present in Tree"<<endl;
	}
}
void Tree::Insert_pos(Node* root){
	int data;
	cout<<"Enter a data you want to insert"<<endl;
	cin >> data;
	Node* new_node = new Node();
	new_node->data = data;
	int d;
	cout<<"After which node you want to insert"<<endl;
	cin >> d;
	Node* c= search(root,d);
	cout<<"Left or right of "<<d<<" (l/r)"<<endl;
	char ans;
	cin >> ans;
	if(ans=='l' && c->left!=NULL){
		cout<<"cannot insert"<<endl;
	}else if(ans =='r' && c->right!=NULL){
		cout<<"Cannot insert"<<endl;
	}else if(ans=='l'){
		c->left = new_node;
	}else if(ans=='r'){
		c->right = new_node;
	}else{
		cout<<"Enter correct option "<<endl;
	}
}

Node* Tree:: Mirror_bt(Node* T ,Node* S){
	 if(T == NULL)
	        {
	            T = new Node(S->data);
	        }
	        if(S->right != NULL)
	        {
	            T->left = new Node(S->right->data);
	            T->left = Mirror_bt(T->left,S->right);
	        }
	        if(S->left != NULL)
	        {
	            T->right = new Node(S->left->data);
	            T->right = Mirror_bt(T->right,S->left);
	        }
	        return T;


}
void Tree :: Mirror(Tree T)
   {
       this->root = Mirror_bt(this->root,T.root);
   }


int Tree:: height(Node* root){
	if(root==NULL){
		return 0;
	}

	int l = height(root->left);
	int r = height(root->right);
	return max(l,r)+1;
}

int Tree:: internal(Node *T)
{
    if(T == NULL)
    {
        return 0;
    }
    if(T->left == NULL && T->right == NULL)
    {
        return 0;
    }
    return 1+internal(T->left) + internal(T->right);
}
int Tree  :: leaf(Node *T)
{
    if(T == NULL)
    {
        return 0;
    }
    if(T->left == NULL && T->right == NULL)
    {
        return 1;
    }
    return leaf(T->left) + leaf(T->right);
}
Node*  Tree :: operator = (Node *S)
{
    if(this->root == NULL)
    {
        this->root = new Node(S->data);
    }
    if(S->right != NULL)
    {
        root->right = new Node(S->right->data);
        root->right = S->right;
    }
    if(S->left != NULL)
    {
        root->left = new Node(S->left->data);
        root->left = S->left;
    }
    return root;
}


Tree Tree :: operator = (Tree T)
{
    this->root = T.root;
}


int main(){

	Tree t;
	Tree temp;
	Tree copyt;

	cout<<"Welcome "<<endl;
	int flag=1;

	while(flag==1){
		cout<<"---------------------------------------------"<<endl;
		cout<<"1]  create tree"<<endl;
		cout<<"2]  Recursive Preorder Traversal"<<endl;
		cout<<"3]  Recursive Inorder Traversal "<<endl;
		cout<<"4]  Recursive Postorder Traversal"<<endl;
		cout<<"5]  Iterative Preorder Traversal"<<endl;
		cout<<"6]  Iterative Inorder Traversal"<<endl;
		cout<<"7]  Iterative Post order Traversal"<<endl;
		cout<<"8]  Insert node "<<endl;
		cout<<"9]  Mirror Tree "<<endl;
		cout<<"10] Height of Tree "<<endl;
		cout<<"11] Copy Tree"<<endl;
		cout<<"12] Count Nodes in Tree "<<endl;
		cout<<"13] search in Tree "<<endl;
		cout<<"14] Exit"<<endl;
		int ans;
		cin >> ans;
		if(ans==1){
				t.cre();
		}else if(ans==2){
			cout<<"Preorder recursive "<<endl;
			t.Preorder(t.getroot());
			cout<<endl;
		}else if(ans==3){
			cout<<"Inorder recursive "<<endl;
			t.Inorder(t.getroot());
			cout<<endl;
		}else if(ans==4){
			cout<<"Postorder recursive "<<endl;
			t.Postorder(t.getroot());
			cout<<endl;
		}else if(ans==5){
			cout<<"Preorder non-recursive"<<endl;
				t.Preorder_nr(t.getroot());
				cout<<endl;
		}else if(ans==6){
			cout<<"Inorder non-recursive "<<endl;
			t.Inorder_nr(t.getroot());
			cout<<endl;
		}else if(ans==7){
			cout<<"Postorder non-recursive "<<endl;
			t.Postorder_nr(t.getroot());
			cout<<endl;
		}else if(ans==8){
			t.Insert_pos(t.getroot());
			cout<<"Inorder non-recursive "<<endl;
			t.Inorder_nr(t.getroot());
			cout<<endl;
		}else if(ans==9){
			temp.Mirror(t);
			temp.Inorder(temp.getroot());
		}else if(ans==10){
			int h =t.height(t.getroot());
			cout<<"Height of Tree is "<<h<<endl;
		}else if(ans==11){
//				cout<<"Copied tree is\n";
            copyt = t;
            copyt.Inorder(copyt.getroot());
            cout<<endl;
		}else if(ans==12){
			int internal_ = t.internal(t.getroot());
			int leaf_ =t.leaf(t.getroot());
			cout<<"No of Internal node - "<<internal_<<endl;
			cout<<"No of Leaf nodes    - "<<leaf_<<endl;
			cout<<"Total no of nodes   - "<<internal_+leaf_<<endl;
		}else if(ans==13){
			t.search_s();
		}else{
			flag = 2;
			cout<<"Thanks for using our system "<<endl;
		}

	}
}








